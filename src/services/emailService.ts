export interface EmailConfig {
  id: string;
  name: string;
  smtpServer: string;
  smtpPort: number;
  smtpUsername: string;
  smtpPassword: string;
  useTls: boolean;
  fromEmail: string;
  toEmails: string[];
  subjectPrefix: string;
  isActive: boolean;
  thresholds: {
    cpuPercent: number;
    memoryPercent: number;
    diskPercent: number;
    failedLoginThreshold: number;
    networkScanThreshold: number;
    checkInterval: number;
    cooldownPeriod: number;
    enableThreatDetection: boolean;
    sendThreatEmails: boolean;
    criticalIncidentsOnly: boolean;
  };
}

export interface EmailTemplate {
  id: string;
  name: string;
  type: 'system_alert' | 'threat_alert' | 'incident_alert';
  subject: string;
  body: string;
  variables: string[];
}

export interface ThreatAlertData {
  threatType: string;
  severity: string;
  sourceIp: string;
  description: string;
  timestamp: Date;
  indicators: string[];
  affectedSystems: string[];
}

export interface SystemAlertData {
  alertType: string;
  message: string;
  value: number;
  threshold: number;
  timestamp: Date;
  systemInfo: {
    cpuUsage: number;
    memoryUsage: number;
    diskUsage: Record<string, number>;
  };
}

class EmailService {
  private config: EmailConfig | null = null;
  private templates: EmailTemplate[] = [];
  private alertHistory: Map<string, Date> = new Map();

  constructor() {
    this.loadDefaultTemplates();
  }

  private loadDefaultTemplates() {
    this.templates = [
      {
        id: 'system_alert',
        name: 'System Alert',
        type: 'system_alert',
        subject: '{{subjectPrefix}} System Alert - {{alertType}}',
        body: `System Alert Detected

Alert Type: {{alertType}}
Message: {{message}}
Current Value: {{value}}
Threshold: {{threshold}}
Timestamp: {{timestamp}}

Current System Status:
- CPU Usage: {{cpuUsage}}%
- Memory Usage: {{memoryUsage}}%
- Disk Usage: {{diskUsage}}

This alert was generated by the Cybersecurity Operations Center.
Please investigate and take appropriate action.`,
        variables: ['subjectPrefix', 'alertType', 'message', 'value', 'threshold', 'timestamp', 'cpuUsage', 'memoryUsage', 'diskUsage']
      },
      {
        id: 'threat_alert',
        name: 'Threat Alert',
        type: 'threat_alert',
        subject: '{{subjectPrefix}} CYBERSECURITY THREAT - {{threatType}}',
        body: `CYBERSECURITY THREAT DETECTED

Threat Type: {{threatType}}
Severity: {{severity}}
Source IP: {{sourceIp}}
Description: {{description}}
Timestamp: {{timestamp}}

Threat Indicators:
{{indicators}}

Affected Systems:
{{affectedSystems}}

RECOMMENDED ACTIONS:
- Investigate the source IP address immediately
- Check system logs for related activity
- Consider blocking the source if confirmed malicious
- Monitor for additional threats from this source
- Escalate to security team if severity is critical

This alert was generated by the Advanced Threat Detection System.`,
        variables: ['subjectPrefix', 'threatType', 'severity', 'sourceIp', 'description', 'timestamp', 'indicators', 'affectedSystems']
      },
      {
        id: 'incident_alert',
        name: 'Incident Alert',
        type: 'incident_alert',
        subject: '{{subjectPrefix}} Security Incident - {{incidentType}}',
        body: `SECURITY INCIDENT DETECTED

Incident Number: {{incidentNumber}}
Type: {{incidentType}}
Severity: {{severity}}
Status: {{status}}
Description: {{description}}
Timestamp: {{timestamp}}

Source: {{source}}
Target: {{target}}
Affected Systems: {{affectedSystems}}

Response Actions Required:
{{responseActions}}

Please respond immediately and update the incident status in the SOC dashboard.`,
        variables: ['subjectPrefix', 'incidentNumber', 'incidentType', 'severity', 'status', 'description', 'timestamp', 'source', 'target', 'affectedSystems', 'responseActions']
      }
    ];
  }

  async getEmailConfiguration(): Promise<EmailConfig | null> {
    try {
      // Try to load from localStorage first
      const stored = localStorage.getItem('emailConfiguration');
      if (stored) {
        this.config = JSON.parse(stored);
        return this.config;
      }
      
      // Return default configuration
      return {
        id: 'default',
        name: 'Default Configuration',
        smtpServer: '',
        smtpPort: 587,
        smtpUsername: '',
        smtpPassword: '',
        useTls: true,
        fromEmail: '',
        toEmails: [],
        subjectPrefix: '[SECURITY ALERT]',
        isActive: true,
        thresholds: {
          cpuPercent: 80,
          memoryPercent: 85,
          diskPercent: 90,
          failedLoginThreshold: 5,
          networkScanThreshold: 10,
          checkInterval: 60,
          cooldownPeriod: 300,
          enableThreatDetection: true,
          sendThreatEmails: true,
          criticalIncidentsOnly: false
        }
      };
    } catch (error) {
      console.error('Failed to load email configuration:', error);
      return null;
    }
  }

  async saveEmailConfiguration(config: EmailConfig): Promise<void> {
    try {
      // Save to localStorage
      localStorage.setItem('emailConfiguration', JSON.stringify(config));
      this.config = config;
      
      // In a real implementation, you would also save to the database
      console.log('Email configuration saved:', config.name);
    } catch (error) {
      console.error('Failed to save email configuration:', error);
      throw new Error('Failed to save email configuration');
    }
  }

  async getEmailTemplates(): Promise<EmailTemplate[]> {
    return this.templates;
  }

  private renderTemplate(template: string, variables: Record<string, any>): string {
    let rendered = template;
    
    for (const [key, value] of Object.entries(variables)) {
      const placeholder = `{{${key}}}`;
      let replacement = '';
      
      if (Array.isArray(value)) {
        replacement = value.map(item => `- ${item}`).join('\n');
      } else if (typeof value === 'object' && value !== null) {
        replacement = Object.entries(value)
          .map(([k, v]) => `${k}: ${v}`)
          .join('\n');
      } else {
        replacement = String(value || '');
      }
      
      rendered = rendered.replace(new RegExp(placeholder, 'g'), replacement);
    }
    
    return rendered;
  }

  private shouldSendAlert(alertType: string, config: EmailConfig): boolean {
    if (!config.isActive) return false;
    
    const now = new Date();
    const lastSent = this.alertHistory.get(alertType);
    
    if (lastSent) {
      const timeDiff = (now.getTime() - lastSent.getTime()) / 1000;
      if (timeDiff < config.thresholds.cooldownPeriod) {
        return false; // Still in cooldown period
      }
    }
    
    this.alertHistory.set(alertType, now);
    return true;
  }

  async sendTestEmail(config: EmailConfig): Promise<boolean> {
    try {
      // Send test email via backend
      const response = await fetch('http://localhost:8004/api/email/test', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          config: {
            smtpServer: config.smtpServer,
            smtpPort: config.smtpPort,
            smtpUsername: config.smtpUsername,
            smtpPassword: config.smtpPassword,
            useTls: config.useTls,
            fromEmail: config.fromEmail,
            toEmails: config.toEmails,
            subjectPrefix: config.subjectPrefix
          }
        }),
      });
      
      if (response.ok) {
        const result = await response.json();
        console.log('✅ Test email sent successfully:', result.message);
        return true;
      } else {
        const errorData = await response.json();
        console.error('❌ Test email failed:', errorData.error);
        return false;
      }
    } catch (error) {
      console.error('Test email failed:', error);
      return false;
    }
  }

  async sendSystemAlert(alertData: SystemAlertData, config?: EmailConfig): Promise<boolean> {
    try {
      const emailConfig = config || this.config;
      if (!emailConfig) {
        throw new Error('No email configuration available');
      }

      if (!this.shouldSendAlert(alertData.alertType, emailConfig)) {
        console.log(`Alert ${alertData.alertType} skipped due to cooldown period`);
        return true; // Not an error, just skipped
      }

      const template = this.templates.find(t => t.type === 'system_alert');
      if (!template) {
        throw new Error('System alert template not found');
      }

      const variables = {
        subjectPrefix: emailConfig.subjectPrefix,
        alertType: alertData.alertType,
        message: alertData.message,
        value: alertData.value,
        threshold: alertData.threshold,
        timestamp: alertData.timestamp.toLocaleString(),
        cpuUsage: alertData.systemInfo.cpuUsage,
        memoryUsage: alertData.systemInfo.memoryUsage,
        diskUsage: Object.entries(alertData.systemInfo.diskUsage)
          .map(([mount, usage]) => `${mount}: ${usage}%`)
          .join('\n')
      };

      const subject = this.renderTemplate(template.subject, variables);
      const body = this.renderTemplate(template.body, variables);

      return await this.sendEmail(emailConfig, subject, body, 'normal');
    } catch (error) {
      console.error('Failed to send system alert:', error);
      return false;
    }
  }

  async sendThreatAlert(threatData: ThreatAlertData, config?: EmailConfig): Promise<boolean> {
    try {
      const emailConfig = config || this.config;
      if (!emailConfig) {
        throw new Error('No email configuration available');
      }

      if (!emailConfig.thresholds.sendThreatEmails) {
        console.log('Threat emails disabled in configuration');
        return true;
      }

      if (!this.shouldSendAlert(`threat_${threatData.threatType}`, emailConfig)) {
        console.log(`Threat alert ${threatData.threatType} skipped due to cooldown period`);
        return true;
      }

      // Send threat alert via backend
      const response = await fetch('http://localhost:8004/api/email/send', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          config: {
            smtpServer: emailConfig.smtpServer,
            smtpPort: emailConfig.smtpPort,
            smtpUsername: emailConfig.smtpUsername,
            smtpPassword: emailConfig.smtpPassword,
            useTls: emailConfig.useTls,
            fromEmail: emailConfig.fromEmail,
            toEmails: emailConfig.toEmails,
            subjectPrefix: emailConfig.subjectPrefix
          },
          alertType: threatData.threatType,
          title: `${threatData.threatType.toUpperCase()} Threat Detected`,
          message: threatData.description,
          severity: threatData.severity,
          timestamp: threatData.timestamp.toISOString(),
          sourceIp: threatData.sourceIp,
          destinationIp: threatData.sourceIp, // Using sourceIp as destination for now
          threatIndicators: threatData.indicators,
          affectedSystems: threatData.affectedSystems,
          category: 'threat'
        }),
      });
      
      if (response.ok) {
        console.log('✅ Threat alert sent successfully');
        return true;
      } else {
        const errorData = await response.json();
        console.error('❌ Threat alert failed:', errorData.error);
        return false;
      }
    } catch (error) {
      console.error('Failed to send threat alert:', error);
      return false;
    }
  }

  private async sendEmail(config: EmailConfig, subject: string, body: string, priority: 'normal' | 'high' = 'normal'): Promise<boolean> {
    try {
      // Send email via backend email service
      const response = await fetch('http://localhost:8004/api/email/send', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          config: {
            smtpServer: config.smtpServer,
            smtpPort: config.smtpPort,
            smtpUsername: config.smtpUsername,
            smtpPassword: config.smtpPassword,
            useTls: config.useTls,
            fromEmail: config.fromEmail,
            toEmails: config.toEmails,
            subjectPrefix: config.subjectPrefix
          },
          title: subject.replace(config.subjectPrefix, '').trim(),
          message: body,
          severity: priority === 'high' ? 'high' : 'medium',
          timestamp: new Date().toISOString(),
          category: 'system'
        }),
      });
      
      if (response.ok) {
        const result = await response.json();
        console.log('✅ Email sent successfully via backend:', result.message);
        return true;
      } else {
        const errorData = await response.json();
        console.error('❌ Email sending failed:', errorData.error);
        throw new Error(errorData.error || 'Email sending failed');
      }
      
    } catch (error) {
      console.error('Email sending failed:', error);
      throw error;
    }
  }

  async sendIncidentAlert(incident: any, config?: EmailConfig): Promise<boolean> {
    try {
      const emailConfig = config || this.config;
      if (!emailConfig) {
        throw new Error('No email configuration available');
      }

      const template = this.templates.find(t => t.type === 'incident_alert');
      if (!template) {
        throw new Error('Incident alert template not found');
      }

      const variables = {
        subjectPrefix: emailConfig.subjectPrefix,
        incidentNumber: incident.id || 'Unknown',
        incidentType: incident.type || 'Unknown',
        severity: incident.severity || 'medium',
        status: incident.status || 'detected',
        description: incident.description || 'No description available',
        timestamp: (incident.timestamp || new Date()).toLocaleString(),
        source: incident.source || 'Unknown',
        target: incident.target || 'Unknown',
        affectedSystems: incident.affectedSystems || [],
        responseActions: incident.responseActions || []
      };

      const subject = this.renderTemplate(template.subject, variables);
      const body = this.renderTemplate(template.body, variables);

      const priority = incident.severity === 'critical' ? 'high' : 'normal';
      return await this.sendEmail(emailConfig, subject, body, priority);
    } catch (error) {
      console.error('Failed to send incident alert:', error);
      return false;
    }
  }

  // Method to integrate with the existing alert system
  async processAlert(alert: any): Promise<void> {
    try {
      const config = await this.getEmailConfiguration();
      if (!config || !config.isActive) {
        return;
      }

      // Determine alert type and send appropriate email
      if (alert.type === 'threat' || alert.threatType) {
        const threatData: ThreatAlertData = {
          threatType: alert.threatType || alert.type,
          severity: alert.severity || 'medium',
          sourceIp: alert.sourceIp || alert.source || 'Unknown',
          description: alert.description || alert.message,
          timestamp: alert.timestamp || new Date(),
          indicators: alert.indicators || [],
          affectedSystems: alert.affectedSystems || []
        };
        
        await this.sendThreatAlert(threatData, config);
      } else if (alert.type === 'incident') {
        await this.sendIncidentAlert(alert, config);
      } else {
        // System alert
        const systemData: SystemAlertData = {
          alertType: alert.type || 'system_alert',
          message: alert.message || 'System alert detected',
          value: alert.value || 0,
          threshold: alert.threshold || 100,
          timestamp: alert.timestamp || new Date(),
          systemInfo: {
            cpuUsage: 0, // Would be populated with real system data
            memoryUsage: 0,
            diskUsage: {}
          }
        };
        
        await this.sendSystemAlert(systemData, config);
      }
    } catch (error) {
      console.error('Failed to process alert for email:', error);
    }
  }

  // Method to get alert statistics
  getAlertStatistics(): any {
    return {
      totalAlertsSent: this.alertHistory.size,
      lastAlertTime: Array.from(this.alertHistory.values()).sort().pop(),
      alertTypes: Array.from(this.alertHistory.keys())
    };
  }
}

export const emailService = new EmailService();